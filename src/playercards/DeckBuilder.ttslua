local playerCardPanelApi  = require("playercards/PlayerCardPanelApi")
local allCardsBagApi      = require("playercards/AllCardsBagApi")
local deckZoneGUID        = "cba5d4"
local deckObject          = nil
local placingDeck         = false
local placingCard         = false

local cardLookupTable = {
  faction =   function(specInstance, isUpgraded) return allCardsBagApi.getCardsByClassAndLevel({ class = specInstance, upgraded = isUpgraded }) end,
  trait   =   function(specInstance) return allCardsBagApi.getCardsByTrait(specInstance) end,
  special =   function(specInstance) return allCardsBagApi.getCardsBySpecialCriteria(specInstance) end
}

local investigatorData = nil
local sortMethod = "default"
local choiceCount = 0
local choiceButtonParameters = {
  function_owner = self,
  tooltip        = "Left-Click: Select!\nRight-Click: Deselect!",
  scale          = {0.5, 1, 0.5},
  color          = Color.Red,
  width          = 600,
  height         = 250
}
local choiceButtonStatus = {
  [3] = {
    spawned         = false,
    selected        = false,
    position        = { -0.65, 0.1, -0.1 },
    label           = ""
  },
  [4] = {
    spawned         = false,
    selected        = false,
    position        = { 0, 0.1, -0.1 },
    label           = ""
  },
  [5] = {
    spawned         = false,
    selected        = false,
    position        = { 0.65, 0.1, -0.1 },
    label           = ""
  },
  [6] = {
    spawned         = false,
    selected        = false,
    position        = { -0.325, 0.1, 0.25 },
    label           = ""
  },
  [7] = {
    spawned         = false,
    selected        = false,
    position        = { 0.325, 0.1, 0.25 },
    label           = ""
  },
  
}

function onLoad()
  self.createButton({
    function_owner = self,
    label          = "Place Lvl 0",
    click_function = "placeCardsBasic",
    tooltip        = "Left-Click: Place cards!\nRight-Click: Clear cards!",
    position       = { -0.5, 0.1, -0.65 },
    scale          = {0.375, 1, 0.375},
    color          = { 1, 1, 1 },
    width          = 1150,
    height         = 350,
    font_size      = 200
  })
  self.createButton({
    function_owner = self,
    label          = "Place Lvl 1-5",
    click_function = "placeCardsUpgraded",
    tooltip        = "Left-Click: Place cards!\nRight-Click: Clear cards!",
    position       = { 0.5, 0.1, -0.65 },
    scale          = {0.375, 1, 0.375},
    color          = { 1, 1, 1 },
    width          = 1150,
    height         = 350,
    font_size      = 200
  })
  self.createButton({
    function_owner = self,
    label          = "Export",
    click_function = "placeCardsUpgraded",
    tooltip        = "Transform Deck Into Coin!",
    position       = { 0, 0.1, 2 },
    scale          = {0.375, 1, 0.375},
    color          = { 1, 1, 1 },
    width          = 1150,
    height         = 350,
    font_size      = 200
  })
end

function onObjectEnterZone(zone, object)
  if zone.guid == deckZoneGUID and deckObject and not placingDeck and not placingCard then
    log("Entered")
    placingCard = true
    deckObject.putObject(object.reload())
    Wait.frames(function() placingCard = false end, 5)
  end
end

function onObjectLeaveZone(zone, object)
  if zone.guid == deckZoneGUID and deckObject and not placingDeck and not placingCard then
    log("Left")
    local targetId = JSON.decode(object.getGMNotes()).id
    for _, card in ipairs(deckObject.getObjects()) do
      if JSON.decode(card.gm_notes).id == targetId then
        local targetCard = deckObject.takeObject({guid = card.guid})
        Wait.frames(function() destroyObject(targetCard) end, 3)
        -- destroyObject(object)
        break
      end
    end 
  end
end

function onCollisionEnter(info)
  --Detects if PlayerDeck object (a 'Deck Coin') has been placed on the deck builder
  objectData = info.collision_object.getData()
  if objectData.Name == "Deck" then
    deckObject = info.collision_object
    placeDeck()
    playerCardPanelApi.disable()
  elseif info.collision_object.hasTag("Investigator") then
    investigatorData = JSON.decode(info.collision_object.getGMNotes()) 
    broadcastToAll("Investigator Detected: " .. info.collision_object.getName(), Color.Green)
    if investigatorData.deck_requirements.choices then
      createChoiceButtons()
    end
  end  
end

function onCollisionExit(info)
  if objectData.Name == "Deck" then
    removeDeck()
  elseif info.collision_object.hasTag("Investigator") and JSON.decode(info.collision_object.getGMNotes()).id == investigatorData.id then
    investigatorData = nil
    playerCardPanelApi.deleteAll("middle")
    resetChoiceButtons()
  end
end

function onObjectDestroy(object)
  if object == deckObject then
    removeDeck()
  end
end

function createChoiceButtons()
  local buttonCount = 3

  for _, cardSpec in ipairs(investigatorData.deck_options) do
    if cardSpec.choiceName then
      choiceButtonParameters.position   = choiceButtonStatus[buttonCount].position
      choiceButtonParameters.label      = cardSpec.choiceName
      choiceButtonParameters.click_function = "toggleChoiceButton" .. buttonCount
      self.createButton(choiceButtonParameters)
      choiceButtonStatus[buttonCount].spawned = true
      choiceButtonStatus[buttonCount].label = choiceButtonParameters.label
      buttonCount = buttonCount + 1
    end
  end

end

function resetChoiceButtons()
  for i, button in pairs(choiceButtonStatus) do
    if button.spawned then
      self.removeButton(i)
      choiceButtonStatus[i].spawned   = false
      choiceButtonStatus[i].selected  = false
      choiceButtonStatus[i].label     = ""
    end
  end
  choiceCount = 0
end

function toggleChoiceButton3(_, _, alt_click)
  toggleChoiceButton(3, alt_click)
end

function toggleChoiceButton4(_, _, alt_click)
  toggleChoiceButton(4, alt_click)
end

function toggleChoiceButton5(_, _, alt_click)
  toggleChoiceButton(5, alt_click)
end

function toggleChoiceButton6(_, _, alt_click)
  toggleChoiceButton(6, alt_click)
end

function toggleChoiceButton7(_, _, alt_click)
  toggleChoiceButton(7, alt_click)
end

function toggleChoiceButton(buttonIndex, alt_click)
  local buttomParam = nil
  for _, button in ipairs(self.getButtons()) do
    if button.index == buttonIndex then
      buttonParam = button
    end
  end

  if choiceButtonStatus[buttonIndex].selected and alt_click then
    buttonParam.color = Color.Red
    self.editButton(buttonParam)
    choiceButtonStatus[buttonIndex].selected = false
    choiceCount = choiceCount - 1
  elseif not choiceButtonStatus[buttonIndex].selected and not alt_click and choiceCount < investigatorData.deck_requirements.choices then
    buttonParam.color = Color.Green
    self.editButton(buttonParam)
    choiceButtonStatus[buttonIndex].selected = true
    choiceCount = choiceCount + 1
  end
end

function placeDeck()
  placingDeck = true

  local cardList = {
    skillList = {},
    eventList = {},
    assetList = {}
  }
  cardList["limitedCardList"] = {
    skillList = {},
    eventList = {},
    assetList = {}
  }

  for _, card in ipairs(deckObject.getObjects()) do
    local cardId = JSON.decode(card.gm_notes).id
    local cardMetadata = allCardsBagApi.getCardById({ id = cardId }).metadata
    if cardMetadata.type == "Skill" then
      table.insert(cardList.skillList, cardId)
    elseif cardMetadata.type == "Event" then
      table.insert(cardList.eventList, cardId)
    elseif cardMetadata.type == "Asset" then
      table.insert(cardList.assetList, cardId)
    end
  end

  cardList.skillList = allCardsBagApi.sortCardsTable(cardList.skillList)
  cardList.eventList = allCardsBagApi.sortCardsTable(cardList.eventList)
  cardList.assetList = allCardsBagApi.sortCardsTable(cardList.assetList)

  playerCardPanelApi.spawnCardsByType({
    cardList = cardList,
    name = "customDeck",
    startPos = "other",
    spread = true,
    spreadCols = 20,
    targetState = "default"
  })
  Wait.frames(function() placingDeck = false end, 5)
end

function removeDeck()
  deckObject = nil
  playerCardPanelApi.deleteAll("default")
  playerCardPanelApi.enable()
end

function placeCardsBasic(_, _, alt_click)
  placeCards(false, alt_click)
end

function placeCardsUpgraded(_,_, alt_click)
  placeCards(true, alt_click)
end

function placeCards(isUpgraded, alt_click)
  if (alt_click) then
    --Clear all cards
    playerCardPanelApi.deleteAll("middle")
  else
    local choiceSelection = {}
    --Determine investigator placed on object
    if not investigatorData then
      broadcastToAll("No Valid Investigator Card Detected", Color.Red)
      return
    elseif investigatorData.deck_requirements.choices then
      if choiceCount ~= investigatorData.deck_requirements.choices then
        broadcastToAll("Select Additional Options", Color.Red)
        return
      else
        for i, button in pairs(choiceButtonStatus) do
          if button.selected then
            choiceSelection[button.label] = button.label
          end
        end
      end
    end
    deckOptions = investigatorData.deck_options
    local cardSet = {}
    local exclusionSet = {}
    local cardList = {
      skillList = {},
      eventList = {},
      assetList = {}
    }
    cardList["limitedCardList"] = {
      skillList = {},
      eventList = {},
      assetList = {}
    }

    --Find all cards eligible to be used by the target investigator
    for _, cardSpec in ipairs(deckOptions) do
      --determine what type of spec we are dealing with
      local specType = (cardSpec.faction and "faction") or (cardSpec.trait and "trait") or (cardSpec.special and "special")
      if not specType then
        log("Invalid Deckbuilding Specification:")
        log(cardSpec)
      else
        for _, specInstance in ipairs(cardSpec[specType]) do
          if (cardSpec.choiceName == choiceSelection[cardSpec.choiceName]) and ((cardSpec.level.min == 0 and not isUpgraded) or (cardSpec.level.max > 0 and isUpgraded)) then
            for _, cardId in ipairs(cardLookupTable[specType](specInstance, isUpgraded)) do
              local cardMetadata = allCardsBagApi.getCardById({ id = cardId }).metadata
              if isUpgraded == (cardMetadata.level > 0) and cardMetadata.level >= cardSpec.level.min and cardMetadata.level <= cardSpec.level.max then
                if cardSpec.limit and sortMethod == "limited" then
                  insertCardSet(cardSet, cardList.limitedCardList, cardMetadata, cardId, cardSpec["not"], exclusionSet, cardSpec.type)
                else
                  insertCardSet(cardSet, cardList, cardMetadata, cardId, cardSpec["not"], exclusionSet, cardSpec.type)
                end
              end
            end
          end
        end
      end
    end
    --Organizes the card lists, and presents them to the player
    cardList.skillList = allCardsBagApi.sortCardsTable(cardList.skillList)
    cardList.eventList = allCardsBagApi.sortCardsTable(cardList.eventList)
    cardList.assetList = allCardsBagApi.sortCardsTable(cardList.assetList)
    cardList.limitedCardList.skillList = allCardsBagApi.sortCardsTable(cardList.limitedCardList.skillList)
    cardList.limitedCardList.eventList = allCardsBagApi.sortCardsTable(cardList.limitedCardList.eventList)
    cardList.limitedCardList.assetList = allCardsBagApi.sortCardsTable(cardList.limitedCardList.assetList)
    playerCardPanelApi.spawnCardsByType({
      cardList = cardList,
      name = "deckOptions",
      startPos = "deckBuilder",
      spread = true,
      spreadCols = 30,
      targetState = "middle"
    })
  end
end


function insertCardSet(cardSet, cardList, cardMetadata, cardId, isExclusion, exclusionSet, types)
  local allowedTypes = {}
  if types then
    for _, cardType in ipairs(types) do
      allowedTypes[cardType] = true
    end
  else
    allowedTypes = {
      Skill = true,
      Event = true,
      Asset = true
    }
  end
  if isExclusion then
    exclusionSet[cardId] = true
  elseif not cardSet[cardId] and not exclusionSet[cardId] then
    if cardMetadata.type == "Skill" and allowedTypes.Skill then
      table.insert(cardList.skillList, cardId)
      cardSet[cardId] = true
      return true
    elseif cardMetadata.type == "Event" and allowedTypes.Event then
      table.insert(cardList.eventList, cardId)
      cardSet[cardId] = true
      return true
    elseif cardMetadata.type == "Asset" and allowedTypes.Asset then
      table.insert(cardList.assetList, cardId)
      cardSet[cardId] = true
      return true
    end
  end
  return false
end
