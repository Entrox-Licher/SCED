local cardIdIndex = { }
local otherIndex
classIndex = { }
levelIndex = { }
local basicWeaknessList = { }
local uniqueWeaknessList = { }
cycleIndex = { }
traitsIndex = { }
willpowerIconsIndex = { }
intellectIconsIndex = { }
combatIconsIndex = { }
agilityIconsIndex = { }
wildIconsIndex = { }
typeIndex = { }
slotIndex = { }
costIndex = { }
permanentIndex = { }
usesIndex = { }
specialCriteriaIndex = { }

local specialCriteriaManualOverride = {
  heals_horror = {
    "01019",
    "01067",
    "01519",
    "01567",
    "01683",
    "02024",
    "02030",
    "02033",
    "02035",
    "02116",
    "02225",
    "02268",
    "02273",
    "03191",
    "03228",
    "03230",
    "03269",
    "03310",
    "04231",
    "04274",
    "05114",
    "05192",
    "05280",
    "05313",
    "06276",
    "06285",
    "06323",
    "07017",
    "07229",
    "07273",
    "07308",
    "08044",
    "08061",
    "08083",
    "08114",
    "08115",
    "08117",
    "08119",
    "08129",
    "09038",
    "09056",
    "09058",
    "09084",
    "09118",
    "51008",
    "52003",
    "54002",
    "60309",
    "60320",
    "60506",
    "10024"

  },
  heals_damage = {
    "01019",
    "01035",
    "01519",
    "01535",
    "01683",
    "02105",
    "02117",
    "02262",
    "03228",
    "03230",
    "03310",
    "04149",
    "04274",
    "05280",
    "05313",
    "06118",
    "06163",
    "06276",
    "06285",
    "06323",
    "07162",
    "07229",
    "07273",
    "08038",
    "08044",
    "08061",
    "08068",
    "08073",
    "08083",
    "08114",
    "08115",
    "08117",
    "08119",
    "08129",
    "09038",
    "09056",
    "09058",
    "09084",
    "09118",
    "54002",
    "60309"
  },
  parley = {
    "05020",
    "05020-t",
    "09028",
    "09052",
    "04105",
    "10114",
    "10009",
    "10064",
    "09073",
    "10070",
    "10071",
    "10091",
    "09081",
    "09081-t",
    "09088",
    "10057",
    "10026",
    "10083",
    "10074",
    "10081"
  }
}

local indexingDone = false
local allowRemoval = false

function onLoad()
  self.addContextMenuItem("Rebuild Index", startIndexBuild)
  math.randomseed(os.time())
  Wait.frames(startIndexBuild, 30)
end

-- Called by Hotfix bags when they load.  If we are still loading indexes, then
-- the all cards and hotfix bags are being loaded together, and we can ignore
-- this call as the hotfix will be included in the initial indexing.  If it is
-- called once indexing is complete it means the hotfix bag has been added
-- later, and we should rebuild the index to integrate the hotfix bag.
function rebuildIndexForHotfix()
  if (indexingDone) then
    startIndexBuild()
  end
end

-- Resets all current bag indexes
function clearIndexes()
  indexingDone = false
  cardIdIndex = { }
  allCardsIndex = { }
  otherIndex = { }
  classIndex = { }
  classIndex["guardian"] = { }
  classIndex["seeker"] = { }
  classIndex["rogue"] = { }
  classIndex["mystic"] = { }
  classIndex["survivor"] = { }
  classIndex["neutral"] = { }
  classIndex[1] = { }
  classIndex[2] = { }
  classIndex[3] = { }
  levelIndex = { }
  levelIndex[0] = { }
  levelIndex[1] = { }
  levelIndex[2] = { }
  levelIndex[3] = { }
  levelIndex[4] = { }
  levelIndex[5] = { }
  cycleIndex = { }
  traitsIndex = { }
  willpowerIconsIndex = { [0] = { } }
  intellectIconsIndex = { [0] = { } }
  combatIconsIndex    = { [0] = { } }
  agilityIconsIndex   = { [0] = { } }
  wildIconsIndex      = { [0] = { } }
  typeIndex = { }
  slotIndex = { }
  slotIndex["arcane"] = { }
  slotIndex["arcane x2"] = { }
  slotIndex["ally"] = { }
  slotIndex["accessory"] = { }
  slotIndex["body"] = { }
  slotIndex["tarot"] = { }
  slotIndex["hand"] = { }
  slotIndex["hand x2"] = { }
  slotIndex[1] = { }
  slotIndex[2] = { }
  slotIndex[3] = { }
  costIndex = { } 
  permanentIndex = { }
  usesIndex = { }
  specialCriteriaIndex = specialCriteriaManualOverride
  basicWeaknessList = { }
  uniqueWeaknessList = { }
end

-- Clears the bag indexes and starts the coroutine to rebuild the indexes
function startIndexBuild(playerColor)
  clearIndexes()
  startLuaCoroutine(self, "buildIndex")
end

function onObjectLeaveContainer(container, object)
  if (container == self and not allowRemoval) then
    broadcastToAll(
        "Removing cards from the All Player Cards bag may break some functions.  Please replace the card.",
        {0.9, 0.2, 0.2}
    )
  end
end

-- Debug option to suppress the warning when cards are removed from the bag
function setAllowCardRemoval()
  allowRemoval = true
end

-- Create the card indexes by iterating all cards in the bag, parsing their
-- metadata, and creating the keyed lookup tables for the cards.  This is a
-- coroutine which will spread the workload by processing 20 cards before
-- yielding.  Based on the current count of cards this will require
-- approximately 60 frames to complete.
function buildIndex()
  indexingDone = false
  if (self.getData().ContainedObjects == nil) then
    return 1
  end
  for i, cardData in ipairs(self.getData().ContainedObjects) do
    local cardMetadata = JSON.decode(cardData.GMNotes)
    if (cardMetadata ~= nil) then
      addCardToIndex(cardData, cardMetadata)
    end
  end
  local hotfixBags = getObjectsWithTag("AllCardsHotfix")
  for _, hotfixBag in ipairs(hotfixBags) do
    if (#hotfixBag.getObjects() > 0) then
      for i, cardData in ipairs(hotfixBag.getData().ContainedObjects) do
        if cardData.ContainedObjects then
          for j, deepCardData in ipairs(cardData.ContainedObjects) do
            local deepCardMetadata = JSON.decode(deepCardData.GMNotes)
            if deepCardMetadata ~= nil then
              addCardToIndex(deepCardData, deepCardMetadata)
            end
          end
        else
          local cardMetadata = JSON.decode(cardData.GMNotes)
          if cardMetadata ~= nil then
            addCardToIndex(cardData, cardMetadata)
          end
        end
      end
    end
  end
  buildSupplementalIndexes()
  indexingDone = true
  return 1
end

-- Adds a card to any indexes it should be a part of, based on its metadata.
---@param cardData: TTS object data for the card
---@param cardMetadata: SCED metadata for the card
function addCardToIndex(cardData, cardMetadata)
  -- use the ZoopGuid as fallback if no id present
  if cardMetadata.id == nil and cardMetadata.TtsZoopGuid then
    cardMetadata.id = cardMetadata.TtsZoopGuid
  end
  cardIdIndex[cardMetadata.id] = { data = cardData, metadata = cardMetadata }
  if (cardMetadata.alternate_ids ~= nil) then
    for _, alternateId in ipairs(cardMetadata.alternate_ids) do
      cardIdIndex[alternateId] = { data = cardData, metadata = cardMetadata }
    end
  end
end

function buildSupplementalIndexes()
  for cardId, card in pairs(cardIdIndex) do
    local cardData = card.data
    local cardMetadata = card.metadata
    -- If the ID key and the metadata ID don't match this is a duplicate card created by an
    -- alternate_id, and we should skip it
    if cardId == cardMetadata.id then
      -- Add card to the basic weakness list, if appropriate.  Some weaknesses have
      -- multiple copies, and are added multiple times
      if cardMetadata.weakness then
        table.insert(uniqueWeaknessList, cardMetadata.id)
        if cardMetadata.basicWeaknessCount ~= nil then
          for i = 1, cardMetadata.basicWeaknessCount do
            table.insert(basicWeaknessList, cardMetadata.id)
          end
        end
      end

      table.insert(allCardsIndex, cardMetadata.id)

      if cardMetadata.level then
        table.insert(levelIndex[cardMetadata.level], cardMetadata.id)
      else
        otherIndex[cardMetadata.id] = true
      end

      if cardMetadata.class then
        local classString = cardMetadata.class .. "|"
        for class in classString:gmatch("[^|]+") do
          table.insert(classIndex[string.lower(class)], cardMetadata.id)
        end
        local classCount = select(2, string.gsub(classString, "|", ""))
        table.insert(classIndex[classCount], cardMetadata.id)
      end    

      local cycleName = cardMetadata.cycle
      if cycleName ~= nil then
        cycleName = string.lower(cycleName)
        if string.match(cycleName, "return") then
          cycleName = string.sub(cycleName, 11)
        end
        if cycleName == "the night of the zealot" then
          cycleName = "core"
        end
        if cycleIndex[cycleName] == nil then
          cycleIndex[cycleName] = { }
        end
        table.insert(cycleIndex[cycleName], cardMetadata.id)
      end

      local bonded = cardMetadata.bonded

      local checkedTraits = {}
      if cardMetadata.traits then
        for traitString in string.gmatch(cardMetadata.traits, "%w+.") do
          local trait = string.lower(string.gsub(traitString, "[.]", ""))
          checkedTraits[trait] = true
          if traitsIndex[trait] == nil then
            traitsIndex[trait] = { }
          end
          table.insert(traitsIndex[trait], cardMetadata.id)
        end
      end
      -- Old Taboo Code
      -- if bonded then
      --   for _, bondData in ipairs(bonded) do
      --     local bondCardMetadata = cardIdIndex[bondData.id].metadata
      --     for traitString in string.gmatch(bondCardMetadata.traits, "%w+.") do
      --       local trait = string.lower(string.gsub(traitString, "[.]", ""))
      --       if not checkedTraits[trait] then
      --         if traitsIndex[trait] == nil then
      --           traitsIndex[trait] = { }
      --         end
      --         table.insert(traitsIndex[trait], cardMetadata.id)
      --       end
      --     end
      --   end
      -- end

      if cardMetadata.willpowerIcons then
        if not willpowerIconsIndex[cardMetadata.willpowerIcons] then
          willpowerIconsIndex[cardMetadata.willpowerIcons] = { }
        end
        table.insert(willpowerIconsIndex[cardMetadata.willpowerIcons], cardMetadata.id)
      else
        table.insert(willpowerIconsIndex[0], cardMetadata.id)
      end
      if cardMetadata.intellectIcons then
        if not intellectIconsIndex[cardMetadata.intellectIcons] then
          intellectIconsIndex[cardMetadata.intellectIcons] = { }
        end
        table.insert(intellectIconsIndex[cardMetadata.intellectIcons], cardMetadata.id)
      else
        table.insert(intellectIconsIndex[0], cardMetadata.id)
      end
      if cardMetadata.agilityIcons then
        if not agilityIconsIndex[cardMetadata.agilityIcons] then
          agilityIconsIndex[cardMetadata.agilityIcons] = { }
        end
        table.insert(agilityIconsIndex[cardMetadata.agilityIcons], cardMetadata.id)
      else
        table.insert(agilityIconsIndex[0], cardMetadata.id)
      end
      if cardMetadata.combatIcons then
        if not combatIconsIndex[cardMetadata.combatIcons] then
          combatIconsIndex[cardMetadata.combatIcons] = { }
        end
        table.insert(combatIconsIndex[cardMetadata.combatIcons], cardMetadata.id)
      else
        table.insert(combatIconsIndex[0], cardMetadata.id)
      end
      if cardMetadata.wildIcons then
        if not wildIconsIndex[cardMetadata.wildIcons] then
          wildIconsIndex[cardMetadata.wildIcons] = { }
        end
        table.insert(wildIconsIndex[cardMetadata.wildIcons], cardMetadata.id)
      else
        table.insert(wildIconsIndex[0], cardMetadata.id)
      end

      if cardMetadata.type then
        if not typeIndex[string.lower(cardMetadata.type)] then
          typeIndex[string.lower(cardMetadata.type)] = { }
        end
        table.insert(typeIndex[string.lower(cardMetadata.type)], cardMetadata.id)
      end

      if cardMetadata.slot then
        local slotString = cardMetadata.slot .. "|"
        local slotCount = select(2, string.gsub(slotString, "|", ""))
        for slot in slotString:gmatch("[^|]+") do
          table.insert(slotIndex[string.lower(slot)], cardMetadata.id)
          if string.match(slot, " x2") then
            slotCount = slotCount + 1
            table.insert(slotIndex[string.lower(string.sub(slot, 1, -4))], cardMetadata.id)
          end
        end
        table.insert(slotIndex[slotCount], cardMetadata.id)
      end

      if cardMetadata.cost then
        if not costIndex[cardMetadata.cost] then
          costIndex[cardMetadata.cost] = { }
        end
        table.insert(costIndex[cardMetadata.cost], cardMetadata.id)
      end

      if cardMetadata.permanent then
        table.insert(permanentIndex, cardMetadata.id)
      end

      if cardMetadata.uses then
        local usesCount = cardMetadata.uses[1].count or -1
        if not usesIndex[usesCount] then
          usesIndex[usesCount] = { }
        end
        table.insert(usesIndex[usesCount], cardMetadata.id)
        if not usesIndex[string.lower(cardMetadata.uses[1].type)] then
          usesIndex[string.lower(cardMetadata.uses[1].type)] = { }
        end
        table.insert(usesIndex[string.lower(cardMetadata.uses[1].type)], cardMetadata.id)
      end
      -- Old Taboo Code
      -- if bonded then
      --   for _, bondData in ipairs(bonded) do
      --     local bondCardMetadata = cardIdIndex[bondData.id].metadata
      --     if bondCardMetadata.uses then
      --       if not usesIndex[bondCardMetadata.uses[1].count] then
      --         usesIndex[bondCardMetadata.uses[1].count] = { }
      --       end
      --       table.insert(usesIndex[bondCardMetadata.uses[1].count], cardMetadata.id)
      --       if not usesIndex[string.lower(bondCardMetadata.uses[1].type)] then
      --         usesIndex[string.lower(bondCardMetadata.uses[1].type)] = { }
      --       end
      --       table.insert(usesIndex[string.lower(bondCardMetadata.uses[1].type)], cardMetadata.id)
      --     end
      --   end
      -- end
        
    end
  end
  
  for _, indexTable in pairs(classIndex) do
    table.sort(indexTable, cardComparator)
  end
  for _, indexTable in pairs(cycleIndex) do
    table.sort(indexTable)
  end
  for _, indexTable in pairs(traitsIndex) do
    table.sort(indexTable, cardComparator)
  end
  for _, indexTable in pairs(specialCriteriaIndex) do
    table.sort(indexTable, cardComparator)
  end
  table.sort(basicWeaknessList, cardComparator)
  table.sort(uniqueWeaknessList, cardComparator)
end

-- Comparison function used to sort the class card bag indexes.  Sorts by card
-- level, then name, then subname.
function cardComparator(id1, id2)
  local card1 = cardIdIndex[id1]
  local card2 = cardIdIndex[id2]
  local card1Level = card1.metadata.level or -1
  local card2Level = card2.metadata.level or -1
  local card1Class = card1.metadata.class or "X"
  if string.find(card1Class, "|") then
    card1Class = "Multi"
  end
  local card2Class = card2.metadata.class or "X"
  if string.find(card2Class, "|") then
    card2Class = "Multi"
  end
  local cardClassOrder = {
    X = 0,
    Guardian = 1,
    Seeker = 2,
    Rogue = 3,
    Mystic = 4,
    Survivor = 5,
    Neutral = 6,
    Multi = 7
  }
  card1Class = cardClassOrder[card1Class]
  card2Class = cardClassOrder[card2Class]

  if (card1Level ~= card2Level) then
    return card1Level < card2Level
  end
  if card1Class ~= card2Class then
    return card1Class < card2Class
  end
  if (card1.data.Nickname ~= card2.data.Nickname) then
    return card1.data.Nickname < card2.data.Nickname
  end
  return card1.data.Description < card2.data.Description
end

function sortCardsTable (cardsTable)
  return table.sort(cardsTable, cardComparator)
end

function isIndexReady()
  return indexingDone
end

-- Returns a specific card from the bag, based on ArkhamDB ID
-- Params table:
--     id: String ID of the card to retrieve
-- Return: If the indexes are still being constructed, an empty table is
--     returned.  Otherwise, a single table with the following fields
--       cardData: TTS object data, suitable for spawning the card
--       cardMetadata: Table of parsed metadata
function getCardById(params)
  if (not indexingDone) then
    broadcastToAll("Still loading player cards, please try again in a few seconds", {0.9, 0.2, 0.2})
    return { }
  end
  return cardIdIndex[params.id]
end

-- Used to index into the supplemental card indices 
---@param indexName exact string of the index variable to be referenced, minus the 'Index' part
---@param includeOthers boolean of whether or not to include non-player cards
---@param value key used to index into the dictionary
---@param value2 optional second key used to index into the sub-dictionary
---@return List of cards located at the precise index given the provided parameters
function getCardsByData(params)
  -- Make sure indices are finished building
  if (not indexingDone) then
    broadcastToAll("Still loading player cards, please try again in a few seconds", {0.9, 0.2, 0.2})
    return { }
  end
  -- Clean up string input
  local value = nil
  if params.value then
    if tonumber(params.value) then
      value = tonumber(params.value)
    else
      value = string.lower(params.value)
    end
  end

  local value2 = nil
  if params.value2 then
    if tonumber(params.value2) then
      value2 = tonumber(params.value2)
    else
      value2 = string.lower(params.value2)
    end
  end

  -- Use global environment variable manipulation to get the corresponding index
  local cardList = _G[params.indexName .. "Index"]
  if not cardList then
    log("Error!  Invalid index requested!")
    return { }
  end
  if value then
    cardList = cardList[value]
  end
  if value2 then
    cardList = cardList[value2]
  end

  -- If invalid search parameters were entered, return an empty list
  if not cardList then
    -- Check to see if a term was accidentally pluralized i.e. 'charges'
    if _G[params.indexName .. "Index"][string.sub(value, 1, -2)] then
      cardList = _G[params.indexName .. "Index"][string.sub(value, 1, -2)]
    else
      log("Invalid search parameters")
      return {}
    end
  end

  -- If including non-player cards, return here
  if includeOthers then
    return cardList
  end

  -- If not including non-player cards, filter them out and then return
  local returnList = {}
  for _, cardId in ipairs(cardList) do
    if not otherIndex[cardId] then
      table.insert(returnList, cardId)
    end
  end
  return returnList
end

function getOppositeCards(params)
  local filter = params.filter or "id"
  if (not indexingDone) then
    broadcastToAll("Still loading player cards, please try again in a few seconds", {0.9, 0.2, 0.2})
    return { }
  end
  local baseCards = {}
  for _, card in ipairs(params.cardList) do
    baseCards[card] = true
  end
  local oppositeCards = {}
  for _, cardId in ipairs(getCardsByData({includeOthers = params.includeOthers, indexName = "allCards"})) do
    if not baseCards[cardId] and cardIdIndex[cardId].metadata[filter] then
      table.insert(oppositeCards, cardId)
    end
  end
  return oppositeCards
end

-- Searches the bag for cards which match the given name and returns a list.  Note that this is
-- an O(n) search without index support.  It may be slow.
-- Parameter array must contain these fields to define the search:
--   name String or string fragment to search for names
--   exact Whether the name match should be exact
function getCardsByName(params)
  local name = params.name
  local exact = params.exact
  local results = { }
  -- Track cards (by ID) that we've added to avoid duplicates that may come from alternate IDs
  local addedCards = { }
  for _, cardData in pairs(cardIdIndex) do
    if (not addedCards[cardData.metadata.id]) then
      if (exact and (string.lower(cardData.data.Nickname) == string.lower(name)))
          or (not exact and string.find(string.lower(cardData.data.Nickname), string.lower(name), 1, true)) then
            table.insert(results, cardData)
            addedCards[cardData.metadata.id] = true
      end
    end
  end
  return results
end

-- Gets a random basic weakness from the bag.  Once a given ID has been returned
-- it will be removed from the list and cannot be selected again until a reload
-- occurs or the indexes are rebuilt, which will refresh the list to include all
-- weaknesses.
-- Return: String ID of the selected weakness.
function getRandomWeaknessId()
    local availableWeaknesses = buildAvailableWeaknesses()
  if (#availableWeaknesses > 0) then
    return availableWeaknesses[math.random(#availableWeaknesses)]
  end
end

-- Constructs a list of available basic weaknesses by starting with the full pool of basic
-- weaknesses then removing any which are currently in the play or deck construction areas
-- Return: Table array of weakness IDs which are valid to choose from
function buildAvailableWeaknesses()
  local weaknessesInPlay = { }
  local allObjects = getAllObjects()
  for _, object in ipairs(allObjects) do
    if (object.name == "Deck") then
      for _, cardData in ipairs(object.getData().ContainedObjects) do
        local cardMetadata = JSON.decode(cardData.GMNotes)
        incrementWeaknessCount(weaknessesInPlay, cardMetadata)
      end
    elseif (object.name == "Card") then
      local cardMetadata = JSON.decode(object.getGMNotes())
      incrementWeaknessCount(weaknessesInPlay, cardMetadata)
    end
  end

  local availableWeaknesses = { }
  for _, weaknessId in ipairs(basicWeaknessList) do
    if (weaknessesInPlay[weaknessId] ~= nil and weaknessesInPlay[weaknessId] > 0) then
      weaknessesInPlay[weaknessId] = weaknessesInPlay[weaknessId] - 1
    else
      table.insert(availableWeaknesses, weaknessId)
    end
  end
  return availableWeaknesses
end

function getBasicWeaknesses()
  return basicWeaknessList
end

function getUniqueWeaknesses()
  return uniqueWeaknessList
end

-- Helper function that adds one to the table entry for the number of weaknesses in play
function incrementWeaknessCount(table, cardMetadata)
  if (isBasicWeakness(cardMetadata)) then
    if (table[cardMetadata.id] == nil) then
      table[cardMetadata.id] = 1
    else
      table[cardMetadata.id] = table[cardMetadata.id] + 1
    end
  end
end

function isBasicWeakness(cardMetadata)
  return cardMetadata ~= nil
    and cardMetadata.weakness
    and cardMetadata.basicWeaknessCount ~= nil
    and cardMetadata.basicWeaknessCount > 0
end
