local chaosBagApi = require("chaosbag/ChaosBagApi")
local deckImporterApi = require("arkhamdb/DeckImporterApi")
local mythosAreaApi = require("core/MythosAreaApi")
local navigationOverlayApi = require("core/NavigationOverlayApi")
local tokenChecker = require("core/token/TokenChecker")
local tokenManager = require("core/token/TokenManager")

-- set true to enable debug logging and show Physics.cast()
local DEBUG = false

-- we use this to turn off collision handling until onLoad() is complete
local collisionEnabled = false

-- position offsets relative to mat [x, y, z]
local DRAWN_ENCOUNTER_CARD_OFFSET = {1.365, 0.5, -0.625}
local DRAWN_CHAOS_TOKEN_OFFSET = {-1.55, 0.25, -0.58}

-- x-Values for discard buttons
local DISCARD_BUTTON_OFFSETS = {-1.365, -0.91, -0.455, 0, 0.455, 0.91}

local SEARCH_AROUND_SELF_X_BUFFER = 8

-- defined areas for "inArea()" and "Physics.cast()"
local MAIN_PLAY_AREA = {
  upperLeft = {
    x = 1.98,
    z = 0.736
  },
  lowerRight = {
    x = -0.79,
    z = -0.39
  }
}
local INVESTIGATOR_AREA = {
  upperLeft = {
    x = -1.084,
    z = 0.06517
  },
  lowerRight = {
    x = -1.258,
    z = -0.0805
  }
}
local THREAT_AREA = {
  upperLeft = {
    x = 1.53,
    z = -0.34
  },
  lowerRight = {
    x = -1.13,
    z = -0.92
  }
}
local DECK_DISCARD_AREA = {
  upperLeft = {
    x = -1.62,
    z = 0.855
  },
  lowerRight = {
    x = -2.02,
    z = -0.245
  },
  center = {
    x = -1.82,
    y = 0.1,
    z = 0.305
  },
  size = {
    x = 0.4,
    y = 0.1,
    z = 1.1
  }
}

-- local position of draw and discard pile
local DRAW_DECK_POSITION    = { x = -1.82, y = 0, z = 0 }
local DISCARD_PILE_POSITION = { x = -1.82, y = 0, z = 0.61 }

-- global position of encounter discard pile
local ENCOUNTER_DISCARD_POSITION = { x = -3.85, y = 1.5, z = 10.38}

-- global variable so it can be reset by the Clean Up Helper
activeInvestigatorId = "00000"

local TRASHCAN, STAT_TRACKER, RESOURCE_COUNTER
local isDrawButtonVisible = false

-- global variable to report "Dream-Enhancing Serum" status
isDES = false

function onSave()
  return JSON.encode({
    playerColor = playerColor,
    activeInvestigatorId = activeInvestigatorId,
    isDrawButtonVisible = isDrawButtonVisible
  })
end

function onLoad(saveState)
  self.interactable = DEBUG

  TRASHCAN = getObjectFromGUID(TRASHCAN_GUID)
  STAT_TRACKER = getObjectFromGUID(STAT_TRACKER_GUID)
  RESOURCE_COUNTER = getObjectFromGUID(RESOURCE_COUNTER_GUID)

  -- button creation
  for i = 1, 6 do
    makeDiscardButton(DISCARD_BUTTON_OFFSETS[i], i)
  end

  self.createButton({
    click_function = "drawEncounterCard",
    function_owner = self,
    position = {-1.84, 0, -0.65},
    rotation = {0, 80, 0},
    width = 265,
    height = 190
  })

  self.createButton({
    click_function = "drawChaosTokenButton",
    function_owner = self,
    position = {1.85, 0, -0.74},
    rotation = {0, -45, 0},
    width = 135,
    height = 135
  })

  self.createButton({
    label = "Upkeep",
    click_function = "doUpkeep",
    function_owner = self,
    position = {1.84, 0.1, -0.44},
    scale = {0.12, 0.12, 0.12},
    width = 800,
    height = 280,
    font_size = 180
  })

  -- save state loading
  local state = JSON.decode(saveState)
  if state ~= nil then
    playerColor = state.playerColor
    activeInvestigatorId = state.activeInvestigatorId
    isDrawButtonVisible = state.isDrawButtonVisible
  end

  showDrawButton(isDrawButtonVisible)

  collisionEnabled = true

  math.randomseed(os.time())
end

---------------------------------------------------------
-- utility functions
---------------------------------------------------------

-- searches an area and optionally filters the result
function searchArea(origin, size, filter)
  local searchResult = Physics.cast({
    origin       = origin,
    direction    = { 0, 1, 0 },
    orientation  = self.getRotation(),
    type         = 3,
    size         = size,
    max_distance = 1
  })

  local objList = {}
  for _, v in ipairs(searchResult) do
    if not filter or (filter and filter(v.hit_object)) then
      table.insert(objList, v.hit_object)
    end
  end
  return objList
end

-- filter functions for searchArea()
function isCard(x) return x.type == 'Card' end
function isDeck(x) return x.type == 'Deck' end
function isCardOrDeck(x) return x.type == 'Card' or x.type == 'Deck' end

-- Finds all objects on the playmat and associated set aside zone.
function searchAroundSelf(filter)
  local bounds = self.getBoundsNormalized()
  -- Increase the width to cover the set aside zone
  bounds.size.x = bounds.size.x + SEARCH_AROUND_SELF_X_BUFFER
  -- Since the cast is centered on the position, shift left or right to keep the non-set aside edge
  -- of the cast at the edge of the playmat
  -- setAsideDirection accounts for the set aside zone being on the left or right, depending on the
  -- table position of the playmat
  local setAsideDirection = bounds.center.z > 0 and 1 or -1
  local localCenter = self.positionToLocal(bounds.center)
  localCenter.x = localCenter.x + setAsideDirection * SEARCH_AROUND_SELF_X_BUFFER / 2 / self.getScale().x
  return searchArea(self.positionToWorld(localCenter), bounds.size, filter)
end

-- searches the area around the draw deck and discard pile
function searchDeckAndDiscardArea(filter)
  local pos = self.positionToWorld(DECK_DISCARD_AREA.center)
  local scale = self.getScale()
  local size = {
    x = DECK_DISCARD_AREA.size.x * scale.x,
    y = DECK_DISCARD_AREA.size.y, 
    z = DECK_DISCARD_AREA.size.z * scale.z
  }
  return searchArea(pos, size, filter)
end

function doNotReady(card)
  return card.getVar("do_not_ready") or false
end

---------------------------------------------------------
-- Discard buttons
---------------------------------------------------------

-- builds a function that discards things in searchPosition
-- stuff on the card/deck will be put into the local trashcan
function makeDiscardHandlerFor(searchPosition)
  return function ()
    local origin = self.positionToWorld(searchPosition)
    for _, obj in ipairs(searchArea(origin, {2, 1, 3.2})) do
      if isCardOrDeck(obj) then
        if obj.hasTag("PlayerCard") then
          placeOrMergeIntoDeck(obj, returnGlobalDiscardPosition(), self.getRotation())
        else
          placeOrMergeIntoDeck(obj, ENCOUNTER_DISCARD_POSITION, {x = 0, y = -90, z = 0})
        end
      -- put chaos tokens back into bag (e.g. Unrelenting)
      elseif tokenChecker.isChaosToken(obj) then
        local chaosBag = chaosBagApi.findChaosBag()
        chaosBag.putObject(obj)
      -- don't touch the table or this playmat itself
      elseif obj.guid ~= "4ee1f2" and obj ~= self then
        TRASHCAN.putObject(obj)
      end
    end
  end
end

-- places a card/deck at a position or merges into an existing deck
-- rotation is optional
function placeOrMergeIntoDeck(obj, pos, rot)
  if not pos then return end

  local offset = 0.5
  local deck, card, newPos
  
  -- search the new position for existing card/deck
  local searchResult = searchArea(pos, { 1, 1, 1 }, isCardOrDeck)
  if #searchResult == 1 then
    local match = searchResult[1]
    if match.type == 'Card' then
      card = match
    elseif match.type == 'Deck' then
      deck = match
    end
  end

  -- update vertical component of new position
  if card or deck then
    local bounds = searchResult[1].getBounds()
    newPos = Vector(pos):setAt("y", bounds.center.y + bounds.size.y / 2 + offset)
  else
    newPos = Vector(pos) + Vector(0, offset, 0)
  end

  -- actual movement of the object
  if rot then
    obj.setRotationSmooth(rot, false, true)
  end
  obj.setPositionSmooth(newPos, false, true)
  
  -- this avoids a TTS bug that merges unrelated cards that are not resting
  if deck then
    Wait.time(function() deck.putObject(obj) end, 0.3)
  elseif card then
    Wait.time(function() obj.setPosition(newPos) end, 0.3)
  end
end

-- build a discard button to discard from searchPosition (number must be unique)
function makeDiscardButton(xValue, number)
  local position = { xValue, 0.1, -0.94}
  local searchPosition = {-position[1], position[2], position[3] + 0.32}
  local handler = makeDiscardHandlerFor(searchPosition)
  local handlerName = 'handler' .. number
  self.setVar(handlerName, handler)
  self.createButton({
    label = "Discard",
    click_function = handlerName,
    function_owner = self,
    position = position,
    scale = {0.12, 0.12, 0.12},
    width = 900,
    height = 350,
    font_size = 220
  })
end

---------------------------------------------------------
-- Upkeep button
---------------------------------------------------------

-- calls the Upkeep function with correct parameter
function doUpkeepFromHotkey(color)
  doUpkeep(_, color)
end

function doUpkeep(_, clickedByColor, isRightClick)
  -- right-click allow color changing
  if isRightClick then
    changeColor(clickedByColor)
    return
  end

  -- send messages to player who clicked button if no seated player found
  messageColor = Player[playerColor].seated and playerColor or clickedByColor

  -- unexhaust cards in play zone, flip action tokens and find forcedLearning
  local forcedLearning = false
  local rot = self.getRotation()
  for _, obj in ipairs(searchAroundSelf()) do
    if obj.getDescription() == "Action Token" and obj.is_face_down then
      obj.flip()
    elseif obj.type == "Card" and not inArea(self.positionToLocal(obj.getPosition()), INVESTIGATOR_AREA) then
      local cardMetadata = JSON.decode(obj.getGMNotes()) or {}
      if not doNotReady(obj) then
        local cardRotation = round(obj.getRotation().y, 0) - rot.y
        local yRotDiff = 0

        if cardRotation < 0 then
          cardRotation = cardRotation + 360
        end

        -- rotate cards to the next multiple of 90° towards 0°
        if cardRotation > 90 and cardRotation <= 180 then
          yRotDiff = 90
        elseif cardRotation < 270 and cardRotation > 180 then
          yRotDiff = 270
        end

        -- set correct rotation for face-down cards
        rot.z = obj.is_face_down and 180 or 0
        obj.setRotation({rot.x, rot.y + yRotDiff, rot.z})
      end
      if cardMetadata.id == "08031" then
        forcedLearning = true
      end
      if cardMetadata.uses ~= nil then
        tokenManager.maybeReplenishCard(obj, cardMetadata.uses, self)
      end
    end
  end

  -- flip investigator mini-card and summoned servitor mini-card
  -- (all characters allowed to account for custom IDs - e.g. 'Z0000' for TTS Zoop generated IDs)
  if activeInvestigatorId ~= nil then
    local miniId = string.match(activeInvestigatorId, ".....") .. "-m"
    for _, obj in ipairs(getObjects()) do
      if obj.type == "Card" and obj.is_face_down then
        local notes = JSON.decode(obj.getGMNotes())
        if notes ~= nil and notes.type == "Minicard" and (notes.id == miniId or notes.id == "09080-m") then
          obj.flip()
        end
      end
    end
  end

  -- gain a resource (or two if playing Jenny Barnes)
  if string.match(activeInvestigatorId, "%d%d%d%d%d") == "02003" then
    gainResources(2)
    printToColor("Gaining 2 resources (Jenny)", messageColor)
  else
    gainResources(1)
  end

  -- draw a card (with handling for Patrice and Forced Learning)
  if activeInvestigatorId == "06005" then
    if forcedLearning then
      printToColor("Wow, did you really take 'Versatile' to play Patrice with 'Forced Learning'? Choose which draw replacement effect takes priority and draw cards accordingly.", messageColor)
    else
      local handSize = #Player[playerColor].getHandObjects()
      if handSize < 5 then
        local cardsToDraw = 5 - handSize
        printToColor("Drawing " .. cardsToDraw .. " cards (Patrice)", messageColor)
        drawCardsWithReshuffle(cardsToDraw)
      end
    end
  elseif forcedLearning then
    printToColor("Drawing 2 cards, discard 1 (Forced Learning)", messageColor)
    drawCardsWithReshuffle(2)
  elseif activeInvestigatorId == "89001" then
    printToColor("Drawing 2 cards (Subject 5U-21)", messageColor)
    drawCardsWithReshuffle(2)
  else
    drawCardsWithReshuffle(1)
  end
end

-- adds the specified amount of resources to the resource counter
function gainResources(amount)
  local count = RESOURCE_COUNTER.getVar("val")
  local add = tonumber(amount) or 0
  RESOURCE_COUNTER.call("updateVal", count + add)
end

-- returns the resource counter amount
function getResourceCount()
  return RESOURCE_COUNTER.getVar("val")
end

-- function for "draw 1 button" (that can be added via option panel)
function doDrawOne(_, color)
  -- send messages to player who clicked button if no seated player found
  messageColor = Player[playerColor].seated and playerColor or color
  drawCardsWithReshuffle(1)
end

-- draw X cards (shuffle discards if necessary)
function drawCardsWithReshuffle(numCards)
  getDrawDiscardDecks()

  -- Norman Withers handling
  if string.match(activeInvestigatorId, "%d%d%d%d%d") == "08004" then
    local harbinger = false
    if topCard ~= nil and topCard.getName() == "The Harbinger" then harbinger = true
    elseif drawDeck ~= nil and not drawDeck.is_face_down then
      local cards = drawDeck.getObjects()
      if cards[#cards].name == "The Harbinger" then harbinger = true end
    end

    if harbinger then
      printToColor("The Harbinger is on top of your deck, not drawing cards", messageColor)
      return
    end

    if topCard ~= nil then
      topCard.deal(numCards, playerColor)
      numCards = numCards - 1
      if numCards == 0 then return end
    end
  end

  local deckSize = 1
  if drawDeck == nil then
    deckSize = 0
  elseif drawDeck.tag == "Deck" then
    deckSize = #drawDeck.getObjects()
  end

  if deckSize >= numCards then
    drawCards(numCards)
    return
  end

  drawCards(deckSize)
  if discardPile ~= nil then
    shuffleDiscardIntoDeck()
    Wait.time(|| drawCards(numCards - deckSize), 1)
  end
  printToColor("Take 1 horror (drawing card from empty deck)", messageColor)
end

-- get the draw deck and discard pile objects
function getDrawDiscardDecks()
  drawDeck = nil
  discardPile = nil
  topCard = nil

  for _, object in ipairs(searchDeckAndDiscardArea(isCardOrDeck)) do
    if self.positionToLocal(object.getPosition()).z > 0.5 then
      discardPile = object
    -- Norman Withers handling
    elseif string.match(activeInvestigatorId, "%d%d%d%d%d") == "08004" and not object.is_face_down then
      topCard = object
    else
      drawDeck = object
    end
  end
end

function drawCards(numCards)
  if drawDeck == nil then return end
  drawDeck.deal(numCards, playerColor)
end

function shuffleDiscardIntoDeck()
  if not discardPile.is_face_down then discardPile.flip() end
  discardPile.shuffle()
  discardPile.setPositionSmooth(self.positionToWorld(DRAW_DECK_POSITION), false, false)
  drawDeck = discardPile
  discardPile = nil
end

-- discard a random non-hidden card from hand
function doDiscardOne()
  local hand = Player[playerColor].getHandObjects()
  if #hand == 0 then
    broadcastToAll("Cannot discard from empty hand!", "Red")
  else
    local choices = {}
    for i = 1, #hand do
      local notes = JSON.decode(hand[i].getGMNotes())
      if notes ~= nil then
        if notes.hidden ~= true then
          table.insert(choices, i)
        end
      else
        table.insert(choices, i)
      end
    end

    if #choices == 0 then
      broadcastToAll("Hidden cards can't be randomly discarded.", "Orange")
      return
    end

    -- get a random non-hidden card (from the "choices" table)
    local num = math.random(1, #choices)
    placeOrMergeIntoDeck(hand[choices[num]], returnGlobalDiscardPosition(), self.getRotation())
    broadcastToAll(playerColor .. " randomly discarded card " .. choices[num] .. "/" .. #hand .. ".", "White")
  end
end

---------------------------------------------------------
-- color related functions
---------------------------------------------------------

-- changes the player color
function changeColor(clickedByColor)
  local colorList = {
    "White",
    "Brown",
    "Red",
    "Orange",
    "Yellow",
    "Green",
    "Teal",
    "Blue",
    "Purple",
    "Pink"
  }

  -- remove existing colors from the list of choices
  for _, existingColor in ipairs(Player.getAvailableColors()) do
    for i, newColor in ipairs(colorList) do
      if existingColor == newColor then
        table.remove(colorList, i)
      end
    end
  end

  -- show the option dialog for color selection to the player that triggered this
  Player[clickedByColor].showOptionsDialog("Select a new color:", colorList, _, function(color)
    local HAND_ZONE_GUIDS = {
      "a70eee", -- White
      "5fe087", -- Orange
      "0285cc", -- Green
      "be2f17"  -- Red
    }
    local index
    local startPos = self.getPosition()

    -- get respective hand zone by position
    if startPos.x < -42 then
      if startPos.z > 0 then
        index = 1
      else
        index = 2
      end
    else
      if startPos.z > 0 then
        index = 3
      else
        index = 4
      end
    end

    -- update the color of the hand zone
    local handZone = getObjectFromGUID(HAND_ZONE_GUIDS[index])
    handZone.setValue(color)

    -- if the seated player clicked this, reseat him to the new color
    if clickedByColor == playerColor then
      navigationOverlayApi.copyVisibility(playerColor, color)
      Player[playerColor].changeColor(color)
    end

    -- update the internal variable
    playerColor = color
  end)
end

---------------------------------------------------------
-- playmat token spawning
---------------------------------------------------------

-- Finds all customizable cards in this play area and updates their metadata based on the selections
-- on the matching upgrade sheet.
-- This method is theoretically O(n^2), and should be used sparingly.  In practice it will only be
-- called when a checkbox is added or removed in-game (which should be rare), and is bounded by the
-- number of customizable cards in play.
function syncAllCustomizableCards()
  for _, card in ipairs(searchAroundSelf(isCard)) do
    syncCustomizableMetadata(card)
  end
end

function syncCustomizableMetadata(card)
  local cardMetadata = JSON.decode(card.getGMNotes()) or { }
  if cardMetadata == nil or cardMetadata.customizations == nil then
    return
  end
  for _, upgradeSheet in ipairs(searchAroundSelf(isCard)) do
    local upgradeSheetMetadata = JSON.decode(upgradeSheet.getGMNotes()) or { }
    if upgradeSheetMetadata.id == (cardMetadata.id .. "-c") then
      for i, customization in ipairs(cardMetadata.customizations) do
        if customization.replaces ~= nil and customization.replaces.uses ~= nil then
          -- Allowed use of call(), no APIs for individual cards
          if upgradeSheet.call("isUpgradeActive", i) then
            cardMetadata.uses = customization.replaces.uses
            card.setGMNotes(JSON.encode(cardMetadata))
          else
            -- TODO: Get the original metadata to restore it... maybe.  This should only be
            -- necessary in the very unlikely case that a user un-checks a previously-full upgrade
            -- row while the card is in play.  It will be much easier once the AllPlayerCardsApi is
            -- in place, so defer until it is
          end
        end
      end
    end
  end
end

function spawnTokensFor(object)
  local extraUses = { }
  if activeInvestigatorId == "03004" then
    extraUses["Charge"] = 1
  end

  tokenManager.spawnForCard(object, extraUses)
end

-- Modelled after onDeckResult from arkhamdb/ArkhamDb.ttslua, but with some necessary changes
function spawnDeckFromToken(coin)
  local deckData = JSON.decode(coin.getGMNotes())
    destroyObject(coin)
    deckData["playerColor"] = playerColor
    -- Add Investigator Cards
    deckData["slots"][deckData.investigatorId] = 1
    deckData["slots"][string.sub(deckData.investigatorId, 1, 5) .. "-m"] = 1
    -- Add Bonded Cards
    for bondedId, bondedCount in pairs(deckData.bondedList) do
      deckData.slots[bondedId] = bondedCount
    end
    -- Add Customizable Upgrade Sheets
    
    -- Add Summon Servitor minicard
    if deckData.slots["09080"] ~= nil then
      deckData.slots["09080-m"] = 1
    end
    -- Add On The Mend


    deckImporterApi.loadCards(deckData)
end

function onCollisionEnter(collision_info)
  local object = collision_info.collision_object

  -- detect if "Dream-Enhancing Serum" is placed
  if object.getName() == "Dream-Enhancing Serum" then isDES = true end

  -- only continue if loading is completed
  if not collisionEnabled then return end

  if object.hasTag("DeckBuilderToken") then
    spawnDeckFromToken(object)
  end

  -- only continue for cards
  if object.type ~= "Card" then return end

  maybeUpdateActiveInvestigator(object)
  syncCustomizableMetadata(object)

  local localCardPos = self.positionToLocal(object.getPosition())
  if inArea(localCardPos, DECK_DISCARD_AREA) then
    tokenManager.resetTokensSpawned(object)
    removeTokensFromObject(object)
  elseif shouldSpawnTokens(object) then
    spawnTokensFor(object)
  end
end

-- detect if "Dream-Enhancing Serum" is removed
function onCollisionExit(collision_info)
  if collision_info.collision_object.getName() == "Dream-Enhancing Serum" then isDES = false end
end

-- checks if tokens should be spawned for the provided card
function shouldSpawnTokens(card)
  if card.is_face_down then
    return false
  end

  local localCardPos = self.positionToLocal(card.getPosition())
  local metadata = JSON.decode(card.getGMNotes())

  -- If no metadata we don't know the type, so only spawn in the main area
  if metadata == nil then
    return inArea(localCardPos, MAIN_PLAY_AREA)
  end

  -- Spawn tokens for assets and events on the main area
  if inArea(localCardPos, MAIN_PLAY_AREA)
      and (metadata.type == "Asset"
      or metadata.type == "Event") then
    return true
  end

  -- Spawn tokens for all encounter types in the threat area
  if inArea(localCardPos, THREAT_AREA)
      and (metadata.type == "Treachery"
      or metadata.type == "Enemy"
      or metadata.weakness) then
    return true
  end

  return false
end

function onObjectEnterContainer(container, object)
  Wait.frames(function() resetTokensIfInDeckZone(container, object) end, 1)
end

function resetTokensIfInDeckZone(container, object)
  local pos = self.positionToLocal(container.getPosition())
  if inArea(pos, DECK_DISCARD_AREA) then
    tokenManager.resetTokensSpawned(object)
    removeTokensFromObject(container)
  end
end

-- removes tokens from the provided card/deck
function removeTokensFromObject(object)
  for _, obj in ipairs(searchArea(object.getPosition(), { 3, 1, 4 })) do
    if obj.getGUID() ~= "4ee1f2" and -- table
        obj ~= self and
        obj.type ~= "Deck" and
        obj.type ~= "Card" and
        obj.memo ~= nil and
        obj.getLock() == false and
        obj.getDescription() ~= "Action Token" and
        not tokenChecker.isChaosToken(obj) then
      TRASHCAN.putObject(obj)
    end
  end
end

---------------------------------------------------------
-- investigator ID grabbing and skill tracker
---------------------------------------------------------

function maybeUpdateActiveInvestigator(card)
  if not inArea(self.positionToLocal(card.getPosition()), INVESTIGATOR_AREA) then return end

  local notes = JSON.decode(card.getGMNotes())
  local class

  if notes ~= nil and notes.type == "Investigator" and notes.id ~= nil then
    if notes.id == activeInvestigatorId then return end
    class = notes.class
    activeInvestigatorId = notes.id
    STAT_TRACKER.call("updateStats", {notes.willpowerIcons, notes.intellectIcons, notes.combatIcons, notes.agilityIcons})
  elseif activeInvestigatorId ~= "00000" then
    class = "Neutral"
    activeInvestigatorId = "00000"
    STAT_TRACKER.call("updateStats", {1, 1, 1, 1})
  else
    return
  end

  -- change state of action tokens
  local search = searchArea(self.positionToWorld({-1.1, 0.05, -0.27}), {4, 1, 1})
  local smallToken = nil
  local STATE_TABLE = {
    ["Guardian"] = 1,
    ["Seeker"]   = 2,
    ["Rogue"]    = 3,
    ["Mystic"]   = 4,
    ["Survivor"] = 5,
    ["Neutral"]  = 6
  }

  for _, obj in ipairs(search) do
    if obj.getDescription() == "Action Token" and obj.getStateId() > 0 then
      if obj.getScale().x < 0.4 then
        smallToken = obj
      else
        setObjectState(obj, STATE_TABLE[class])
      end
    end
  end

  -- update the small token with special action for certain investigators
  local SPECIAL_ACTIONS = {
    ["04002"]    = 8,  -- Ursula Downs
    ["01002"]    = 9,  -- Daisy Walker
    ["01502"]    = 9,  -- Daisy Walker
    ["01002-pb"] = 9,  -- Daisy Walker
    ["06003"]    = 10, -- Tony Morgan
    ["04003"]    = 11, -- Finn Edwards
    ["08016"]    = 14  -- Bob Jenkins
  }

  if smallToken ~= nil then
    setObjectState(smallToken, SPECIAL_ACTIONS[activeInvestigatorId] or STATE_TABLE[class])
  end
end

function setObjectState(obj, stateId)
  if obj.getStateId() ~= stateId then obj.setState(stateId) end
end

---------------------------------------------------------
-- calls to 'Global' / functions for calls from outside
---------------------------------------------------------

function drawChaosTokenButton(_, _, isRightClick)
  chaosBagApi.drawChaosToken(self, DRAWN_CHAOS_TOKEN_OFFSET, isRightClick)
end

function drawEncounterCard(_, _, isRightClick)
  local pos = self.positionToWorld(DRAWN_ENCOUNTER_CARD_OFFSET)
  local rotY = self.getRotation().y
  mythosAreaApi.drawEncounterCard(pos, rotY, isRightClick)
end

function returnGlobalDiscardPosition()
  return self.positionToWorld(DISCARD_PILE_POSITION)
end

-- Sets this playermat's draw 1 button to visible
---@param visible Boolean.  Whether the draw 1 button should be visible
function showDrawButton(visible)
  isDrawButtonVisible = visible

  -- create the "Draw 1" button
  if isDrawButtonVisible then
    self.createButton({
        label = "Draw 1",
        click_function = "doDrawOne",
        function_owner = self,
        position = { 1.84, 0.1, -0.36 },
        scale = { 0.12, 0.12, 0.12 },
        width = 800,
        height = 280,
        font_size = 180
    })

  -- remove the "Draw 1" button
  else
    local buttons = self.getButtons()
    for i = 1, #buttons do
      if buttons[i].label == "Draw 1" then
        self.removeButton(buttons[i].index)
      end
    end
  end
end

-- Spawns / destroys a clickable clue counter for this playmat with the correct amount of clues
---@param showCounter Boolean Whether the clickable clue counter should be present
function clickableClues(showCounter)
  local CLUE_COUNTER = getObjectFromGUID(CLUE_COUNTER_GUID)
  local CLUE_CLICKER = getObjectFromGUID(CLUE_CLICKER_GUID)
  local clickerPos = CLUE_CLICKER.getPosition()
  local clueCount = 0

  if showCounter then
    -- current clue count
    clueCount = CLUE_COUNTER.getVar("exposedValue")

    -- remove clues
    CLUE_COUNTER.call("removeAllClues")

    -- set value for clue clickers
    CLUE_CLICKER.call("updateVal", clueCount)

    -- move clue counters up
    clickerPos.y = 1.52
    CLUE_CLICKER.setPosition(clickerPos)
  else
    -- current clue count
    clueCount = CLUE_CLICKER.getVar("val")

    -- move clue counters down
    clickerPos.y = 1.3
    CLUE_CLICKER.setPosition(clickerPos)

    -- spawn clues
    local pos = self.positionToWorld({x = -1.12, y = 0.05, z = 0.7})
    for i = 1, clueCount do
      pos.y = pos.y + 0.045 * i
      tokenManager.spawnToken(pos, "clue", self.getRotation())
    end
  end
end

-- removes all clues (moving tokens to the trash and setting counters to 0)
function removeClues()
  local CLUE_COUNTER = getObjectFromGUID(CLUE_COUNTER_GUID)
  local CLUE_CLICKER = getObjectFromGUID(CLUE_CLICKER_GUID)

  CLUE_COUNTER.call("removeAllClues")
  CLUE_CLICKER.call("updateVal", 0)
end

-- reports the clue count
---@param useClickableCounters Boolean Controls which type of counter is getting checked
function getClueCount(useClickableCounters)
  local count = 0

  if useClickableCounters then
    local CLUE_CLICKER = getObjectFromGUID(CLUE_CLICKER_GUID)
    count = tonumber(CLUE_CLICKER.getVar("val"))
  else
    local CLUE_COUNTER = getObjectFromGUID(CLUE_COUNTER_GUID)
    count = tonumber(CLUE_COUNTER.getVar("exposedValue"))
  end
  return count
end

-- Sets this playermat's snap points to limit snapping to matching card types or not.  If matchTypes
-- is true, the main card slot snap points will only snap assets, while the investigator area point
-- will only snap Investigators.  If matchTypes is false, snap points will be reset to snap all
-- cards.
---@param matchTypes Boolean.  Whether snap points should only snap for the matching card types.
function setLimitSnapsByType(matchTypes)
  local snaps = self.getSnapPoints()
  for i, snap in ipairs(snaps) do
    local snapPos = snap.position
    if inArea(snapPos, MAIN_PLAY_AREA) then
      local snapTags = snaps[i].tags
      if matchTypes then
        if snapTags == nil then
          snaps[i].tags = { "Asset" }
        else
          table.insert(snaps[i].tags, "Asset")
        end
      else
        snaps[i].tags = nil
      end
    end
    if inArea(snapPos, INVESTIGATOR_AREA) then
      local snapTags = snaps[i].tags
      if matchTypes then
        if snapTags == nil then
          snaps[i].tags = { "Investigator" }
        else
          table.insert(snaps[i].tags, "Investigator")
        end
      else
        snaps[i].tags = nil
      end
    end
  end
  self.setSnapPoints(snaps)
end

-- Simple method to check if the given point is in a specified area.  Local use only,
---@param point Vector Point to check, only x and z values are relevant
---@param bounds Table Defined area to see if the point is within.  See MAIN_PLAY_AREA for sample
--     bounds definition.
---@return Boolean True if the point is in the area defined by bounds
function inArea(point, bounds)
  return (point.x < bounds.upperLeft.x
      and point.x > bounds.lowerRight.x
      and point.z < bounds.upperLeft.z
      and point.z > bounds.lowerRight.z)
end

-- called by custom data helpers to add player card data
---@param args table Contains only one entry, the GUID of the custom data helper
function updatePlayerCards(args)
  local customDataHelper = getObjectFromGUID(args[1])
  local playerCardData = customDataHelper.getTable("PLAYER_CARD_DATA")
  tokenManager.addPlayerCardData(playerCardData)
end

-- utility function for rounding
---@param num Number Initial value
---@param numDecimalPlaces Number Amount of decimal places
function round(num, numDecimalPlaces)
  local mult = 10^(numDecimalPlaces or 0)
  return math.floor(num * mult + 0.5) / mult
end
