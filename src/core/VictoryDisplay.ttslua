local searchLib        = require("util/SearchLib")
local chaosBagApi      = require("chaosbag/ChaosBagApi")
local guidReferenceApi = require("core/GUIDReferenceApi")
local playAreaApi      = require("core/PlayAreaApi")
local tokenChecker     = require("core/token/TokenChecker")

local pendingCall      = false
local missingData      = {}
local countedVP        = {}

local highlightMissing = false
local highlightCounted = false

-- button creation when loading the game
function onLoad()
  -- index 0: VP - "Display"
  local buttonParameters          = {}
  buttonParameters.label          = "0"
  buttonParameters.click_function = "none"
  buttonParameters.function_owner = self
  buttonParameters.scale          = { 0.15, 0.15, 0.15 }
  buttonParameters.width          = 0
  buttonParameters.height         = 0
  buttonParameters.font_size      = 600
  buttonParameters.font_color     = { 1, 1, 1 }
  buttonParameters.position       = { x = -0.72, y = 0.06, z = -0.69 }
  self.createButton(buttonParameters)

  -- index 1: VP - "Play Area"
  buttonParameters.position.x = 0.65
  self.createButton(buttonParameters)

  -- index 2: VP - "Total"
  buttonParameters.position.x = 1.69
  self.createButton(buttonParameters)

  -- index 3: highlighting button (missing data)
  buttonParameters.label          = "!"
  buttonParameters.click_function = "highlightMissingData"
  buttonParameters.tooltip        = "Enable highlighting of cards without metadata (VP on these is not counted)."
  buttonParameters.color          = { 1, 0, 0 }
  buttonParameters.width          = 700
  buttonParameters.height         = 800
  buttonParameters.font_size      = 700
  buttonParameters.position       = { x = 1.82, y = 0.06, z = -1.32 }
  self.createButton(buttonParameters)

  -- index 4: highlighting button (counted VP)
  buttonParameters.label          = "?"
  buttonParameters.click_function = "highlightCountedVP"
  buttonParameters.tooltip        = "Enable highlighting of cards with VP."
  buttonParameters.color          = { 0, 1, 0 }
  buttonParameters.position.x     = 1.5
  self.createButton(buttonParameters)

  -- update the display label once
  Wait.time(updateCount, 1)
end

---------------------------------------------------------
-- events with descriptions
---------------------------------------------------------

-- dropping an object on the victory display
function onCollisionEnter()
  startUpdate()
end

-- removing an object from the victory display
function onCollisionExit()
  startUpdate()
end

-- picking a clue or location up
function onObjectPickUp(_, obj)
  maybeUpdate(obj)
end

-- dropping a clue or location
function onObjectDrop(_, obj)
  maybeUpdate(obj, 1)
end

-- flipping a clue/doom or location
function onObjectRotate(obj, _, flip, _, _, oldFlip)
  if flip == oldFlip then return end
  maybeUpdate(obj, 1, true)
end

-- destroying a clue or location
function onObjectDestroy(obj)
  maybeUpdate(obj)
end

---------------------------------------------------------
-- main functionality
---------------------------------------------------------

function maybeUpdate(obj, delay, flipped)
  -- stop if there is already an update call running
  if pendingCall then return end

  -- stop if obj is nil (by e.g. dropping a clue onto another and making a stack)
  if obj == nil then return end

  -- only continue for clues / doom tokens or locations
  if obj.hasTag("Location") then
  elseif obj.memo == "clueDoom" then
    -- only continue if the clue side is up or a doom token is being flipped
    if obj.is_face_down == true and flipped ~= true then return end
  else
    return
  end

  -- only continue if the obj in in the play area
  if not playAreaApi.isInPlayArea(obj) then return end

  startUpdate(delay)
end

-- starts an update
function startUpdate(delay)
  -- stop if there is already an update call running
  if pendingCall then return end
  pendingCall = true
  delay = tonumber(delay) or 0
  Wait.time(updateCount, delay + 0.2)
end

-- counts the VP in the victory display and request the VP count from the play area
function updateCount()
  missingData            = {}
  countedVP              = {}
  local victoryPoints    = {}
  victoryPoints.display  = 0
  victoryPoints.playArea = playAreaApi.countVP()

  -- count cards in victory display
  for _, obj in ipairs(searchLib.onObject(self), "isCardOrDeck") do
    -- check metadata for VP
    if obj.type == "Card" then
      local VP = getCardVP(obj, JSON.decode(obj.getGMNotes()))
      victoryPoints.display = victoryPoints.display + VP
      if VP > 0 then
        table.insert(countedVP, obj)
      end

      -- handling for stacked cards
    elseif obj.type == "Deck" then
      local VP = 0
      for _, deepObj in ipairs(obj.getObjects()) do
        local deepVP = getCardVP(obj, JSON.decode(deepObj.gm_notes))
        victoryPoints.display = victoryPoints.display + deepVP
        if deepVP > 0 then
          VP = VP + 1
        end
      end
      if VP > 0 then
        table.insert(countedVP, obj)
      end
    end
  end

  -- update the buttons that are used as labels
  self.editButton({ index = 0, label = victoryPoints.display })
  self.editButton({ index = 1, label = victoryPoints.playArea })
  self.editButton({ index = 2, label = victoryPoints.display + victoryPoints.playArea })

  -- allow new update calls
  pendingCall = false
end

-- gets the VP count from the notes
function getCardVP(obj, notes)
  local cardVP
  if notes ~= nil then
    -- enemy, treachery etc.
    cardVP = tonumber(notes.victory)

    -- location
    if not cardVP then
      -- check the correct side of the location
      if not obj.is_face_down and notes.locationFront ~= nil then
        cardVP = tonumber(notes.locationFront.victory)
      elseif notes.locationBack ~= nil then
        cardVP = tonumber(notes.locationBack.victory)
      end
    end
    if (cardVP or 0) > 0 then
      table.insert(countedVP, obj)
    end
  else
    table.insert(missingData, obj)
  end
  return cardVP or 0
end

-- toggles the highlight for objects with missing metadata
function highlightMissingData()
  self.editButton({
    index = 3,
    tooltip = (highlightMissing and "Enable" or "Disable") .. " highlighting of cards without metadata (VP on these is not counted)." })
  for _, obj in pairs(missingData) do
    if obj ~= nil then
      if highlightMissing then
        obj.highlightOff("Red")
      else
        obj.highlightOn("Red")
      end
    end
  end
  playAreaApi.highlightMissingData(highlightMissing)
  highlightMissing = not highlightMissing
end

-- toggles the highlight for objects that were counted
function highlightCountedVP()
  self.editButton({
    index = 4,
    tooltip = (highlightCounted and "Enable" or "Disable") .. " highlighting of cards with VP."
  })
  for _, obj in pairs(countedVP) do
    if obj ~= nil then
      if highlightCounted then
        obj.highlightOff("Green")
      else
        obj.highlightOn("Green")
      end
    end
  end
  playAreaApi.highlightCountedVP(highlightCounted)
  highlightCounted = not highlightCounted
end

-- places the provided card in the first empty spot
function placeCard(card)
  local trash = guidReferenceApi.getObjectByOwnerAndType("Mythos", "Trash")

  -- check snap point states
  local snaps = self.getSnapPoints()
  table.sort(snaps, function(a, b) return a.position.x > b.position.x end)
  table.sort(snaps, function(a, b) return a.position.z < b.position.z end)

  -- get first empty slot
  local fullSlots = {}
  local positions = {}
  for i, snap in ipairs(snaps) do
    positions[i] = self.positionToWorld(snap.position)
    local searchResult = searchLib.atPosition(positions[i], "isCardOrDeck")
    fullSlots[i] = #searchResult > 0
  end

  -- remove tokens from the card
  for _, obj in ipairs(searchLib.onObject(card)) do
    -- don't touch decks / cards
    if obj.type == "Deck" or obj.type == "Card" then
      -- put chaos tokens back into bag
    elseif tokenChecker.isChaosToken(obj) then
      local chaosBag = chaosBagApi.findChaosBag()
      chaosBag.putObject(obj)
    elseif obj.memo ~= nil and obj.getLock() == false then
      trash.putObject(obj)
    end
  end

  -- place the card
  local name = card.getName() or "Unnamed card"
  for i = 1, 10 do
    if fullSlots[i] ~= true then
      local rot = { 0, 270, card.getRotation().z }
      card.setPositionSmooth(positions[i], false, true)
      card.setRotation(rot)
      broadcastToAll("Victory Display: " .. name .. " placed into slot " .. i .. ".", "Green")
      return
    end
  end

  broadcastToAll("Victory Display is full! " .. name .. " placed into slot 1.", "Orange")
  card.setPositionSmooth(positions[1], false, true)
end
