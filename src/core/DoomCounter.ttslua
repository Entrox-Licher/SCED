local guidReferenceApi = require("core/GUIDReferenceApi")
local playAreaApi = require("core/PlayAreaApi")

local optionsVisible = false
local options = {
  Agenda = true,
  Playarea = true,
  Playermats = true
}

val = 0

-- save current value and options
function onSave() return JSON.encode({ val, options }) end

function onLoad(savedData)
  if savedData ~= "" then
    local loadedData = JSON.decode(savedData)
    val              = loadedData[1]
    options          = loadedData[2]

    -- restore state for option panel
    for key, bool in pairs(options) do
      self.UI.setAttribute("option" .. key, "isOn", not bool)
    end
  end

  self.createButton({
    label          = tostring(val),
    click_function = "addOrSubtract",
    function_owner = self,
    position       = { 0, 0.06, 0 },
    height         = 800,
    width          = 800,
    font_size      = 650,
    scale          = { 1.5, 1.5, 1.5 },
    font_color     = { 1, 1, 1, 95 },
    color          = { 0, 0, 0, 0 }
  })
end

-- called by the invisible button to change displayed value
function addOrSubtract(_, _, isRightClick)
  local newVal = math.min(math.max(val + (isRightClick and -1 or 1), 0), 99)
  if val ~= newVal then
    updateVal(newVal)
  end
end

-- adds the provided number to the current count
function addVal(number)
  number = tonumber(number) or 0
  val = val + number
  self.editButton({ index = 0, label = tostring(val) })
  broadcastDoom(val)
end

-- sets the current count to the provided number
function updateVal(number)
  val = number or 0
  self.editButton({ index = 0, label = tostring(val) })
  broadcastDoom(val)
end

--called by updateVal and addVal to broadcast total doom in play, including doom threshold
function broadcastDoom(val)
  
  if val ~= 0 then
    local doomInPlayCounter = guidReferenceApi.getObjectByOwnerAndType("Mythos", "DoomInPlayCounter")
    otherDoom = doomInPlayCounter.call("countDoom")
    totalDoomThreshold = getDoomThreshold()

    if totalDoomThreshold ~= nil then
      broadcastToAll(val .. " doom on the agenda (" .. otherDoom + val .. "/" .. totalDoomThreshold .. " in play)", "White")
    else
      broadcastToAll(val .. " doom on the agenda (" .. otherDoom + val .. " in play)", "White")
    end
  else
    broadcastToAll("Doom on agenda set to " .. val, "White")
  end
end

-- called by "Reset" button to remove doom
function startReset()
  if options.Agenda then
    updateVal(0)
  end
  local doomInPlayCounter = guidReferenceApi.getObjectByOwnerAndType("Mythos", "DoomInPlayCounter")
  if doomInPlayCounter then
    doomInPlayCounter.call("removeDoom", options)
  end
end

-- get Doom Threshold from top card of Agenda deck
function getDoomThreshold()
 
  local origin = { -2.72, 1.6, 0.37 } -- this needs to be edited to the actual coordinates of the agenda deck
  local size = { 0.1, 0.1, 0.1 } -- very slim area, basically a single raycast
  local searchResult = searchArea(origin, size, isCardOrDeck)
  
  local metadata = {} 
  if #searchResult == 0 then
  -- handle no agenda found
    return nil
  elseif #searchResult == 1 then
    if searchResult[1].type == "Card" then
    -- handle single agenda card
      local cardData = searchResult[1].getData()
      metadata = JSON.decode(cardData.GMNotes)
      if metadata == nil then
        return nil
      else
        if(metadata.doomThresholdPerInvestigator) then

          return metadata.doomThresholdPerInvestigator*playAreaApi.getInvestigatorCount() + metadata.doomThreshold
        else
            return metadata.doomThreshold
        end
      end

    else
    -- handle agenda deck
      
      local cardData = searchResult[1].getData().ContainedObjects
      local topCardData = cardData[#cardData]
      metadata = JSON.decode(topCardData.GMNotes)
      if metadata == nil then
        return nil
      else
        if(metadata.doomThresholdPerInvestigator) then
          return metadata.doomThresholdPerInvestigator*playAreaApi.getInvestigatorCount() + metadata.doomThreshold
        else
          return metadata.doomThreshold
        end
      end
      
    end
    
  else
    -- handle multiple cards / decks found
    return nil
  end
end

-- XML UI functions
function optionClick(_, optionName)
  options[optionName] = not options[optionName]
  printToAll("Doom removal of " .. optionName .. (options[optionName] and " enabled" or " disabled"))
end

function toggleOptions()
  optionsVisible = not optionsVisible

  if optionsVisible then
    self.UI.show("Options")
  else
    self.UI.hide("Options")
  end
end

-- searches an area and optionally filters the result
function searchArea(origin, size, filter)
  local searchResult = Physics.cast({
    origin       = origin,
    direction    = { 0, 1, 0 },
    orientation  = self.getRotation(),
    type         = 3,
    size         = size,
    max_distance = 0
  })

  local objList = {}
  for _, v in ipairs(searchResult) do
    if not filter or (filter and filter(v.hit_object)) then
      table.insert(objList, v.hit_object)
    end
  end
  return objList
end

-- filter functions for searchArea()
function isCard(x) return x.type == 'Card' end
function isDeck(x) return x.type == 'Deck' end
function isCardOrDeck(x) return x.type == 'Card' or x.type == 'Deck' end
